<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A pointee type that supports type-erased pointers (thin pointers)."><title>Erasable in erasable - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="erasable" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0-beta.2 (fe9b9751f 2025-01-11)" data-channel="beta" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../static.files/storage-59e33391.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../erasable/index.html">erasable</a><span class="version">1.3.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Erasable</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#safety" title="Safety">Safety</a></li></ul><h3><a href="#provided-associated-consts">Provided Associated Constants</a></h3><ul class="block"><li><a href="#associatedconstant.ACK_1_1_0" title="ACK_1_1_0">ACK_1_1_0</a></li></ul><h3><a href="#required-methods">Required Methods</a></h3><ul class="block"><li><a href="#tymethod.unerase" title="unerase">unerase</a></li></ul><h3><a href="#provided-methods">Provided Methods</a></h3><ul class="block"><li><a href="#method.erase" title="erase">erase</a></li></ul><h3><a href="#dyn-compatibility">Dyn Compatibility</a></h3><h3><a href="#implementors">Implementors</a></h3></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate erasable</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="index.html">erasable</a></span><h1>Trait <span class="trait">Erasable</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/erasable/lib.rs.html#198-271">Source</a> </span></div><pre class="rust item-decl"><code>pub unsafe trait Erasable {
    const <a href="#associatedconstant.ACK_1_1_0" class="constant">ACK_1_1_0</a>: <a class="primitive" href="https://doc.rust-lang.org/beta/core/primitive.bool.html">bool</a> = false;

    // Required method
    unsafe fn <a href="#tymethod.unerase" class="fn">unerase</a>(this: <a class="type" href="type.ErasedPtr.html" title="type erasable::ErasedPtr">ErasedPtr</a>) -&gt; <a class="struct" href="https://doc.rust-lang.org/beta/core/ptr/non_null/struct.NonNull.html" title="struct core::ptr::non_null::NonNull">NonNull</a>&lt;Self&gt;;

    // Provided method
    fn <a href="#method.erase" class="fn">erase</a>(this: <a class="struct" href="https://doc.rust-lang.org/beta/core/ptr/non_null/struct.NonNull.html" title="struct core::ptr::non_null::NonNull">NonNull</a>&lt;Self&gt;) -&gt; <a class="type" href="type.ErasedPtr.html" title="type erasable::ErasedPtr">ErasedPtr</a> { ... }
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A pointee type that supports type-erased pointers (thin pointers).</p>
<p>This trait is automatically implemented for all sized types,
and can be manually implemented for unsized types that know their own metadata.</p>
<h2 id="safety"><a class="doc-anchor" href="#safety">§</a>Safety</h2>
<p>Must be implemented as described and may be relied upon by generic code.</p>
</div></details><h2 id="provided-associated-consts" class="section-header">Provided Associated Constants<a href="#provided-associated-consts" class="anchor">§</a></h2><div class="methods"><details class="toggle" open><summary><section id="associatedconstant.ACK_1_1_0" class="method"><a class="src rightside" href="../src/erasable/lib.rs.html#262">Source</a><h4 class="code-header">const <a href="#associatedconstant.ACK_1_1_0" class="constant">ACK_1_1_0</a>: <a class="primitive" href="https://doc.rust-lang.org/beta/core/primitive.bool.html">bool</a> = false</h4></section></summary><div class="docblock"><p>Whether this implementor has acknowledged the 1.1.0 update to
<code>unerase</code>’s documented implementation requirements.</p>
<p>Prior to 1.1.0, creating a temporary shared reference (<code>&amp;_</code>) in
<code>unerase</code> was explicitly listed as allowed, but for the 1.1.0 release
it was determined that this in fact can cause problems for some use
cases that <code>Erasable</code> is designed to support.</p>
<p>Implementing this as <code>false</code> is <em>not allowed</em> and is <em>not</em> permission
to create references within <code>unerase</code>. It only exists as a way to
make the soundness fix in 1.1.0 disallowing references not breaking.
You <em>must</em> override this with a value of <code>true</code> and follow the current
documented requirements for <code>unerase</code>, and not create references.</p>
<p>If your use of <code>unerase</code> would be problematic if it creates a temporary
shared reference, you should assert that this value is <code>true</code>.
Not doing so will expose you to potentially unsound implementations
written against 1.0.0 before the reference clarification was made.</p>
<p>The environment variable <code>ERASABLE_ENFORCE_1_1_0_SEMANTICS</code> can be set
to enforce that all implementors have provided an override for this.</p>
</div></details></div><h2 id="required-methods" class="section-header">Required Methods<a href="#required-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="tymethod.unerase" class="method"><a class="src rightside" href="../src/erasable/lib.rs.html#238">Source</a><h4 class="code-header">unsafe fn <a href="#tymethod.unerase" class="fn">unerase</a>(this: <a class="type" href="type.ErasedPtr.html" title="type erasable::ErasedPtr">ErasedPtr</a>) -&gt; <a class="struct" href="https://doc.rust-lang.org/beta/core/ptr/non_null/struct.NonNull.html" title="struct core::ptr::non_null::NonNull">NonNull</a>&lt;Self&gt;</h4></section></summary><div class="docblock"><p>Unerase this erased pointer.</p>
<p>Note that this <em>must</em> be sound to roundtrip pointers with any provenance,
shared, unique, raw, frozen, mutable, and any valid combination thereof.
(In other words, <code>&amp;mut _</code> and <code>&amp;_</code> can be safely erased and unerased, and
any raw pointer should roundtrip without losing the provenance it had.)</p>
<p>Concretely, this means that the resulting pointer <em>must</em> be derived
from the input pointer without any intervening references manifested.
Additionally, no references to the pointee <em>at all</em> should be created,
as their mere temporary existence may impact the validity and
usable provenance of other pointers to the same location.</p>
<p>Creating a shared reference sounds on the surface like it should be ok.
After all, you have a known-valid pointer to your type, and you can
borrow from whatever pointer was erased. However, in the face of raw
pointers with a shared mutable provenance, this is problematic.
If a write to the pointee location even potentially races with any
invocation of <code>unerase</code>, and it creates a reference to the location,
we have immediate undefined behavior for writing behind a shared ref.</p>
<p>The root issue is that there may be external synchronization that this
implementation has no way of knowing about. An implementation of this
trait must only read the mimimum amount of data required to re-type the
pointer, and must do so with a raw pointer read, or, if and only if
there is a known <code>UnsafeCell</code> point (such as an atomic), a reference to
that <code>UnsafeCell</code> point and the safe API of that <code>UnsafeCell</code> point.</p>
<h5 id="safety-1"><a class="doc-anchor" href="#safety-1">§</a>Safety</h5>
<p>The erased pointer must have been created by <code>erase</code>ing a valid pointer.</p>
</div></details></div><h2 id="provided-methods" class="section-header">Provided Methods<a href="#provided-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="method.erase" class="method"><a class="src rightside" href="../src/erasable/lib.rs.html#203-205">Source</a><h4 class="code-header">fn <a href="#method.erase" class="fn">erase</a>(this: <a class="struct" href="https://doc.rust-lang.org/beta/core/ptr/non_null/struct.NonNull.html" title="struct core::ptr::non_null::NonNull">NonNull</a>&lt;Self&gt;) -&gt; <a class="type" href="type.ErasedPtr.html" title="type erasable::ErasedPtr">ErasedPtr</a></h4></section></summary><div class="docblock"><p>Turn this erasable pointer into an erased pointer.</p>
<p>To retrieve the original pointer, use <code>unerase</code>.</p>
</div></details></div><h2 id="dyn-compatibility" class="section-header">Dyn Compatibility<a href="#dyn-compatibility" class="anchor">§</a></h2><div class="dyn-compatibility-info"><p>This trait is <b>not</b> <a href="https://doc.rust-lang.org/beta/reference/items/traits.html#object-safety">dyn compatible</a>.</p><p><i>In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.</i></p></div><h2 id="implementors" class="section-header">Implementors<a href="#implementors" class="anchor">§</a></h2><div id="implementors-list"><details class="toggle implementors-toggle"><summary><section id="impl-Erasable-for-T" class="impl"><a class="src rightside" href="../src/erasable/lib.rs.html#616-623">Source</a><a href="#impl-Erasable-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="https://doc.rust-lang.org/beta/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>&gt; <a class="trait" href="trait.Erasable.html" title="trait erasable::Erasable">Erasable</a> for T</h3></section></summary><div class="impl-items"><section id="associatedconstant.ACK_1_1_0-1" class="associatedconstant trait-impl"><a class="src rightside" href="../src/erasable/lib.rs.html#622">Source</a><a href="#associatedconstant.ACK_1_1_0-1" class="anchor">§</a><h4 class="code-header">const <a href="#associatedconstant.ACK_1_1_0" class="constant">ACK_1_1_0</a>: <a class="primitive" href="https://doc.rust-lang.org/beta/core/primitive.bool.html">bool</a> = true</h4></section></div></details></div><script src="../trait.impl/erasable/trait.Erasable.js" async></script></section></div></main></body></html>